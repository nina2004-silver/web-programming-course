# ЛР4: Управление состоянием (State Management)

## Описание

В этой лабораторной работе вы изучите различные подходы к управлению состоянием в React-приложениях. Вы создадите простое Quiz-приложение, используя разные библиотеки управления состоянием и сравните их подходы.

## Установка зависимостей

```bash
npm install
# или
yarn install
```

## Запуск проекта

```bash
npm run dev
# или
yarn dev
```

## Основные пакеты и их назначение

### 1. **React** (`react`, `react-dom`)
- **Что это**: Основная библиотека для создания пользовательских интерфейсов
- **Зачем нужна**: Создание компонентов и управление UI
- **Версия**: ^18.2.0

### 2. **MobX** (`mobx`, `mobx-react-lite`)
- **Что это**: Библиотека для реактивного управления состоянием
- **Зачем нужна**: Управление бизнес-логикой приложения (данные игры, вопросы, счёт)
- **Философия**: Автоматическое отслеживание изменений через observables
- **Преимущества**:
  - Простой синтаксис (похож на обычный JavaScript)
  - Автоматическая оптимизация ре-рендеров
  - Computed values (вычисляемые значения)
  - ООП-подход с классами
- **Версия**: ^6.12.0

### 3. **Zustand** (`zustand`)
- **Что это**: Минималистичная библиотека управления состоянием
- **Зачем нужна**: Управление UI-состоянием (темы, настройки, модалки)
- **Философия**: Простой и функциональный подход без провайдеров
- **Преимущества**:
  - Очень маленький размер (~1KB)
  - Простой API
  - Нет необходимости в React Context
  - Отличная типизация TypeScript
  - Middleware (persist, devtools, immer)
- **Версия**: ^4.5.0

### 4. **TypeScript** (`typescript`)
- **Что это**: Типизированный JavaScript
- **Зачем нужен**: Типизация кода, автодополнение, поиск ошибок
- **Версия**: ^5.3.0

### 5. **Vite** (`vite`)
- **Что это**: Современный сборщик для фронтенда
- **Зачем нужен**: Быстрая разработка и сборка проекта
- **Преимущества**: Мгновенный HMR, быстрый запуск
- **Версия**: ^5.0.0

### 6. **Tailwind CSS** (`tailwindcss`)
- **Что это**: Utility-first CSS фреймворк
- **Зачем нужен**: Быстрое создание адаптивного дизайна
- **Версия**: ^3.4.0

## Структура проекта

```
src/
├── tasks/              # Задания
│   ├── Task1.tsx       # Чистый React (useState)
│   ├── Task2.tsx       # MobX
│   ├── Task3.tsx       # Zustand
│   └── Task4.tsx       # MobX + Zustand
├── stores/             # Хранилища состояния
│   ├── gameStore.ts    # MobX store (бизнес-логика)
│   └── uiStore.ts      # Zustand store (UI)
├── types/              # TypeScript типы
│   └── quiz.ts
├── data/               # Моковые данные
│   └── questions.ts
├── App.tsx             # Главный компонент
└── main.tsx            # Точка входа
```

## Задания

### Task 1: Чистый React (useState)
**Цель**: Создать простой счётчик вопросов используя только встроенные хуки React

**Что нужно сделать**:
- Использовать `useState` для управления состоянием
- Отобразить вопрос и варианты ответов
- Реализовать подсчёт правильных ответов
- Показать результат

**Что изучается**:
- Локальное состояние компонента
- Базовые хуки React (useState)
- Ограничения при росте приложения

### Task 2: MobX
**Цель**: Переписать логику из Task1 используя MobX

**Что нужно сделать**:
- Создать `GameStore` класс с `makeAutoObservable`
- Использовать `observable` для состояния
- Создать `actions` для изменения состояния
- Добавить `computed` значения (прогресс, процент правильных ответов)
- Обернуть компонент в `observer`

**Что изучается**:
- Реактивное программирование
- Observable state
- Actions и computed values
- Автоматическая оптимизация

### Task 3: Zustand
**Цель**: Создать UI-store для управления настройками приложения

**Что нужно сделать**:
- Создать store с помощью `create()`
- Добавить состояние для темы (светлая/тёмная)
- Добавить состояние для звука (вкл/выкл)
- Использовать селекторы для подписки на изменения
- Добавить persist middleware для сохранения в localStorage

**Что изучается**:
- Функциональный подход к state management
- Селекторы и оптимизация ре-рендеров
- Middleware (persist)
- Работа без провайдеров

### Task 4: MobX + Zustand вместе
**Цель**: Объединить оба подхода в одном приложении

**Что нужно сделать**:
- Взять `GameStore` из Task2 и расширить его
- Взять `UIStore` из Task3 и расширить его
- Создать компонент, использующий оба store
- Добавить новые фичи:
  - Таймер для вопросов (MobX)
  - Статистику игр (MobX)
  - Модальные окна (Zustand)
  - Переключение темы (Zustand)

**Что изучается**:
- Разделение ответственности:
  - **MobX** → Бизнес-логика (вопросы, счёт, таймер, статистика)
  - **Zustand** → UI-состояние (темы, модалки, настройки)
- Интеграция разных библиотек
- Архитектурные паттерны

## Сравнение подходов

| Критерий | useState | MobX | Zustand |
|----------|----------|------|---------|
| **Сложность** | Простой | Средняя | Низкая |
| **Boilerplate** | Минимум | Средний | Минимум |
| **Масштабируемость** | Низкая | Высокая | Высокая |
| **Размер бандла** | 0 KB | ~16 KB | ~1 KB |
| **Стиль кода** | Функции + хуки | ООП + классы | Функции + хуки |
| **Оптимизация** | Ручная | Автоматическая | Селекторы |

## Полезные ссылки

- [Документация MobX](https://mobx.js.org)
- [Документация Zustand](https://github.com/pmndrs/zustand)
- [Гайд по state management](./docs/guide.md)
- [Шпаргалка](./docs/cheatsheet.md)

## Критерии оценки

- Task 1: Правильное использование useState
- Task 2: Правильная работа с MobX (observable, action, computed)
- Task 3: Правильная работа с Zustand (selectors, middleware)
- Task 4: Корректная интеграция обеих библиотек
- Качество кода и типизация
- Работа приложения

Замечательных выходных!
